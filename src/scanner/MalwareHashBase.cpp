#include "MalwareHashBase.h"

#include <filesystem>
#include <string>
#include <iostream>

constexpr std::string_view FILE_BASE_EXTENSION = ".csv";
constexpr int HASH_STRING_SIZE = 32;

static std::string str_tolower(std::string s) {
    std::transform(s.begin(), s.end(), s.begin(), [](unsigned char c){
        return std::tolower(c);
    });
    return s;
}

MalwareHashBase::MalwareHashBase() {}

MalwareHashBase::MalwareHashBase(const std::string& basePath) {
    m_basePath = basePath;
}

void MalwareHashBase::setBasePath(const std::string& basePath) {
    m_basePath = basePath;
    m_hashToVerdict.clear();
    m_fileIndexSucceeded = false;
    m_linesRead = 0;
    m_baseFile.close();
}

bool MalwareHashBase::checkLineFormat(std::string_view line) const {
    int separatorCount = 0;
    int separatorPosition = -1;
    for (int i = 0; i < line.size() && separatorCount <= 1; i++) {
        if (line[i] == ';') {
            separatorCount++;
            separatorPosition = i;
        }
    }
    return (separatorCount == 1 &&
            separatorPosition == HASH_STRING_SIZE &&
            separatorPosition != line.size()-1);
}

std::pair<Hash, std::string> MalwareHashBase::getHashAndVerdictFromString(const std::string &s) const {
    auto separatorPos = s.find(';');
    std::string_view hash(s.c_str(), separatorPos);
    return {Hash::fromStringView(hash), s.substr(separatorPos + 1)};
}

void MalwareHashBase::openBaseAndSkipToUnread() {
    m_baseFile.open(m_basePath, std::ios::in);
    for (uint64_t curLine = 0; curLine < m_linesRead; ++curLine) {
        m_baseFile.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    }
}

BaseError MalwareHashBase::checkBaseFile() const noexcept {
    if (!std::filesystem::exists(m_basePath))
        return BaseError::NoSuchPath;
    if (std::filesystem::is_directory(m_basePath))
        return BaseError::NotAFile;
    if (auto fileExt = std::filesystem::path(m_basePath).extension().string();
            str_tolower(fileExt) != FILE_BASE_EXTENSION)
        return BaseError::WrongExtension;
    std::ifstream baseFile(m_basePath, std::ios::in);
    if (!baseFile.is_open())
        return BaseError::NoPermissions;
    std::string line;
    while(getline(baseFile, line)) {
        if (!checkLineFormat(line)) {
            return BaseError::WrongFormat;
        }
    }
    return BaseError::Ok;
}

void MalwareHashBase::indexBaseFileContent() {
    openBaseAndSkipToUnread();

    m_fileIndexSucceeded = true;
    std::string line;
    while(getline(m_baseFile, line)) {
        try {
            auto [hash, verdict] = getHashAndVerdictFromString(line);
            m_hashToVerdict.emplace(hash, std::string(verdict));
            m_linesRead++;
        } catch (const std::bad_alloc&) {
            m_fileIndexSucceeded = false;
            break;
        }
    }
    m_baseFile.close();
}

std::optional<std::string> MalwareHashBase::findIndexedHashVerdict(const Hash &hash) const {
    if (auto it = m_hashToVerdict.find(hash); it != m_hashToVerdict.end())
        return it->second;
    return std::nullopt;
}

std::optional<std::string> MalwareHashBase::findHashVerdict(const std::string &hash) {
    return findHashVerdict(Hash::fromString(hash));
}

std::optional<std::string> MalwareHashBase::findHashVerdict(Hash hash) {
    // Если файл зачитан полностью, возвращаем вердикт
    // Если искомый хэш проиндексирован - возвращаем его
    if (m_fileIndexSucceeded)
        return findIndexedHashVerdict(hash);
    if (auto verdict = findIndexedHashVerdict(hash); verdict)
        return verdict;

    // Пробуем читать файл дальше, сколько сможем
    indexBaseFileContent();

    // Если после повторной индексации файл зачитан полностью, возвращаем вердикт
    // Если искомый хэш проиндексирован - возвращаем его
    if (m_fileIndexSucceeded)
        return findIndexedHashVerdict(hash);
    if (auto verdict = findIndexedHashVerdict(hash); verdict)
        return verdict;

    // Если файл не был зачитан полностью и хэш не был найден - ищем построчно
    openBaseAndSkipToUnread();
    std::string line;
    while(getline(m_baseFile, line)) {
        auto [readHash, verdict] = getHashAndVerdictFromString(line);
        if (readHash == hash) {
            return verdict;
        }
    }
    return std::nullopt;
}
